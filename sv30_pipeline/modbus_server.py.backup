import threading
from pymodbus.server import StartTcpServer
from pymodbus.datastore import ModbusSequentialDataBlock, ModbusServerContext
from pymodbus.device import ModbusDeviceIdentification
from sv30config import MODBUS_HOST, MODBUS_PORT

# =====================================================
# REGISTER MAP (Holding Registers 40001-40005)
# =====================================================
# Modbus uses 0-based indexing internally
# User addresses 40001-40005 map to internal 0-4
#
# 40001: SV30_VALUE (% × 100)
# 40002: SETTLING_VELOCITY (%/sec × 10,000)
# 40003: TEST_DURATION (minutes)
# 40004: TEST_END_EPOCH_HI (MSB)
# 40005: TEST_END_EPOCH_LO (LSB)
# =====================================================

# Create datastore with 200 registers initialized to 0
holding_registers = ModbusSequentialDataBlock(0, [0] * 200)

store = ModbusServerContext(
    di=None,  # Discrete Inputs
    co=None,  # Coils
    hr=holding_registers,  # Holding Registers
    ir=None,  # Input Registers
    single=True
)

# =====================================================
# WRITE HELPERS
# =====================================================
def write_register(address, value):
    """
    Write single register
    
    Args:
        address: Modbus address (e.g., 40001)
        value: Integer value to write
    """
    # Convert user address to 0-based index
    index = address - 40001
    
    if index < 0 or index >= 200:
        print(f"[MODBUS ERROR] Invalid address: {address}")
        return
    
    holding_registers.setValues(index, [int(value)])
    print(f"[MODBUS] Register {address} = {int(value)}")

def write_many(start_address, values):
    """
    Write multiple consecutive registers
    
    Args:
        start_address: First Modbus address
        values: List of integer values
    """
    index = start_address - 40001
    
    if index < 0 or (index + len(values)) > 200:
        print(f"[MODBUS ERROR] Invalid address range: {start_address}")
        return
    
    holding_registers.setValues(index, list(map(int, values)))
    print(f"[MODBUS] Registers {start_address}-{start_address+len(values)-1} = {values}")

def read_register(address):
    """
    Read single register (for debugging)
    
    Args:
        address: Modbus address (e.g., 40001)
    
    Returns:
        Register value
    """
    index = address - 40001
    
    if index < 0 or index >= 200:
        print(f"[MODBUS ERROR] Invalid address: {address}")
        return None
    
    values = holding_registers.getValues(index, 1)
    return values[0] if values else None

# =====================================================
# SERVER START
# =====================================================
def _run_server():
    """
    Start Modbus TCP server (blocking)
    Runs in separate thread when called via start_in_thread()
    """
    identity = ModbusDeviceIdentification()
    identity.VendorName = "Autonex"
    identity.ProductCode = "SV30"
    identity.ProductName = "SV30 Analyzer"
    identity.ModelName = "SV30-RPI"
    identity.MajorMinorRevision = "1.0"
    
    print(f"\n[MODBUS] Starting TCP server")
    print(f"  Host: {MODBUS_HOST}")
    print(f"  Port: {MODBUS_PORT}")
    print(f"  Registers: 40001-40005\n")
    
    try:
        StartTcpServer(
            context=store,
            identity=identity,
            address=(MODBUS_HOST, MODBUS_PORT)
        )
    except Exception as e:
        print(f"[MODBUS ERROR] Server failed: {e}")

def start_in_thread():
    """
    Start Modbus server in background thread
    Non-blocking, allows main pipeline to continue
    """
    t = threading.Thread(target=_run_server, daemon=True, name="ModbusServer")
    t.start()
    print("[MODBUS] Server thread started")

if __name__ == "__main__":
    # For testing: run server directly
    _run_server()
